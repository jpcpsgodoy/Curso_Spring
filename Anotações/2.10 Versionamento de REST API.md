
# 🚀 Por que versionar APIs?

- **Manter compatibilidade com clientes antigos**
- **Evitar quebra de funcionalidades** com novas versões
- **Permitir desenvolvimento paralelo** de novas features e correções de bugs
- **Organizar crescimento da API** com controle de versões



## 🔀 Abordagens de versionamento

1. **URI Versioning**: versão na URL  
   Ex: `/api/v1/users`

2. **Request Parameter Versioning**: versão como parâmetro  
   Ex: `/api/users?version=1`

3. **Header Versioning**: versão no cabeçalho HTTP  
   Ex: `Accept: application/vnd.api.v1+json`



## 📦 Exemplo com URI Versioning no Spring Boot

- Crie uma aplicação com Spring Boot e dependência `spring-boot-starter-web`
- Crie um controller com dois métodos, por exemplo:

**Exemplo:**
 

    @GetMapping("/v1/greeting")
    public String getGreetingV1() {
        return "Hello from version 1";
    }
    
    @GetMapping("/v2/greeting")
    public String getGreetingV2() {
        return "Hello from version 2";
    }

-   Ao acessar `/v1/greeting` ou `/v2/greeting`, o usuário recebe uma resposta diferente dependendo da versão
    


## 👥 Exemplo prático: User Service

-   **v1**: retorna dados básicos do usuário (nome, ID)
    
-   **v2**: retorna dados estendidos (nome, ID, email)
    
-   Pode-se organizar os controllers em pacotes separados por versão (`v1`, `v2`) para manter o projeto limpo
    


## 🔢 SemVer – Versionamento Semântico

-   Formato: **MAJOR.MINOR.PATCH**
    
    -   **MAJOR**: mudanças que quebram compatibilidade (ex: 1.x.x → 2.0.0)
        
    -   **MINOR**: novas funcionalidades compatíveis (ex: 1.0.0 → 1.1.0)
        
    -   **PATCH**: correções pequenas (ex: 1.0.0 → 1.0.1)
        

### Exemplos:

-   `1.0.0`: versão inicial com endpoint básico
    
-   `1.0.1`: correção de bug sem afetar a API
    
-   `1.1.0`: novo campo `email` adicionado de forma compatível
    
-   `2.0.0`: mudança que exige alteração no cliente
    


## ✅ Conclusão

-   REST APIs facilitam a interação com dados sem expor a lógica interna
    
-   Versionamento permite evolução controlada da API
    
-   Abordagens como URI versioning são comuns e simples de implementar
    
-   SemVer ajuda a comunicar claramente as mudanças feitas em cada versão
